Timer unit: 1e-07 s

Total time: 41.302 s
File: C:\Users\gupta\Documents\GitHub\SAGA\TSP19simpack\GAutils\est_algo.py
Function: refine_one at line 148

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   148                                                   return

Total time: 16.1982 s
File: C:\Users\gupta\Documents\GitHub\SAGA\TSP19simpack\GAutils\objects.py
Function: get_newfit_error at line 179

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   179                                               @profile    
   180                                               def get_newfit_error(cls, sensors, rnew, dnew, gnew, sidnew):
   181                                                   # Reports geometry fitting error for given R,D pair
   182     34200   13194171.0    385.8      8.1          rn = np.hstack((cls.r, rnew))
   183     34200   10365614.0    303.1      6.4          dn = np.hstack((cls.d, dnew))
   184     34200    9870916.0    288.6      6.1          gn = np.hstack((cls.g, gnew))
   185     34200    1225276.0     35.8      0.8          Me = rn*dn
   186     34200     761121.0     22.3      0.5          Me2 = rn*rn
   187     34200     572347.0     16.7      0.4          Ns = len(rn)
   188     34200    9508028.0    278.0      5.9          sindx_new = np.hstack((cls.sindx,sidnew))
   189     34200    4019415.0    117.5      2.5          L = np.array([sensors[si].x for si in sindx_new])
   190     34200   13890779.0    406.2      8.6          CRB = np.array([sensors[si].getnominalCRB() for i, si in enumerate(sindx_new)]) # Using nominal
   191                                           #        CRB = np.array([sensors[si].getCRB()/(abs(gn[i])**2) for i, si in enumerate(sindx_new)]) # Using est. gain
   192                                                   # Get constants
   193     34200     782580.0     22.9      0.5          Z = cls.Zdict[Ns-2]
   194     34200     577194.0     16.9      0.4          Wi = cls.Widict[Ns-2]
   195     34200   15198620.0    444.4      9.4          ZWZ = np.linalg.multi_dot([Z.T, Wi, Z])
   196                                                   # Main estimator
   197     34200   23723151.0    693.7     14.6          u_vec = ZWZ @ L/np.linalg.multi_dot([L.T, ZWZ, L])
   198                                                   # rd fitting
   199     34200    2543898.0     74.4      1.6          v_hat = -Me @ u_vec # v_x estimate
   200     34200   14392253.0    420.8      8.9          M1var = (np.sum( CRB * np.array([dn**2, rn**2]).T,1) 
   201     34200    7091648.0    207.4      4.4          + np.prod(CRB,1) )
   202                                           #        lb_vx_std = np.sqrt(M1var @ (u_vec**2)) # Std. dev in estimating vx
   203                                                   # Fitting Error compuation (For each target)
   204     34200    5355641.0    156.6      3.3          N_mat = Me @ Z.T + (v_hat *L) @(Z.T) # eta
   205     34200    1360705.0     39.8      0.8          V_mat = N_mat @ Wi  # Optimal dual var.
   206                                                   
   207                                                   # r2 fitting
   208     34200    3650981.0    106.8      2.3          x_hat = -(Me2 - ( L**2 )) @ u_vec/2
   209     34200    5637471.0    164.8      3.5          M2var = (4*CRB[:,0] * np.array( rn**2) + CRB[:,0]**2)# Ignoring higher order terms
   210                                           #        lb_x_std = np.sqrt(M2var @ (u_vec**2)/4) # std. dev in estimating x
   211                                                   # Fitting Error compuation (For each target)
   212     34200    6280995.0    183.7      3.9          N_mat2 = Me2 @ Z.T + 2*x_hat *L @ (Z.T) - ( L*L ) @ Z.T # eta
   213     34200    1282045.0     37.5      0.8          U_mat = N_mat2 @ Wi # Optimal dual var.
   214                                           
   215     34200    8234914.0    240.8      5.1          gc = ((cfg.rd_wt[0]*(V_mat@Z/2)**2/M1var + cfg.rd_wt[1]*((U_mat@Z/2)**2)/M2var))
   216     34200    2462465.0     72.0      1.5          return sum(gc)

Total time: 8.26747 s
File: C:\Users\gupta\Documents\GitHub\SAGA\TSP19simpack\GAutils\objects.py
Function: get_state at line 418

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   418                                               @profile
   419                                               def get_state(cls, sensors):
   420     17114     801257.0     46.8      1.0          Me = cls.r * cls.d
   421     17114     442252.0     25.8      0.5          Me2 = cls.r * cls.r
   422     17114     261947.0     15.3      0.3          Ns = cls.N
   423     17114    2027682.0    118.5      2.5          L = np.array([sensors[si].x for si in cls.sindx])
   424     17114    6808240.0    397.8      8.2          CRB = np.array([sensors[si].getnominalCRB() for (si, gi) in zip(cls.sindx, cls.g)])
   425                                           #        CRB = np.array([sensors[si].getCRB()/(abs(gi)**2) for (si, gi) in zip(cls.sindx, cls.g)])
   426                                                   # Get constants
   427     17114     385552.0     22.5      0.5          Z = cls.Zdict[Ns-2]
   428     17114     293030.0     17.1      0.4          Wi = cls.Widict[Ns-2]
   429                                                   # Main estimator
   430     17114    6347165.0    370.9      7.7          u_vec = Z.T @ Wi @ Z @ L/(L.T @ Z.T @ Wi @ Z @ L)
   431                                                   # rd fitting
   432     17114     976478.0     57.1      1.2          v_hat = -Me @ u_vec # v_x estimate
   433     17114    7357083.0    429.9      8.9          M1var = (np.sum( CRB * np.array([cls.d**2, cls.r**2]).T,1) 
   434     17114    3572984.0    208.8      4.3          + np.prod(CRB,1) )
   435                                           #        lb_vx_std = np.sqrt(M1var @ (u_vec**2)) # Std. dev in estimating vx
   436                                                   # Fitting Error compuation (For each target)
   437     17114    2578365.0    150.7      3.1          N_mat = Me @ Z.T + (v_hat *L) @(Z.T) # eta
   438     17114     656822.0     38.4      0.8          V_mat = N_mat @ Wi  # Optimal dual var.
   439     17114    8137170.0    475.5      9.8          g_nu = np.sqrt(np.sum(N_mat * V_mat) - np.sum((V_mat@Z)**2)/4)
   440                                                   
   441                                                   # r2 fitting
   442     17114    1806161.0    105.5      2.2          x_hat = -(Me2 - ( L**2 )) @ u_vec/2
   443     17114    2945457.0    172.1      3.6          M2var = (4*CRB[:,0] * np.array( cls.r**2) + CRB[:,0]**2)# Ignoring higher order terms
   444                                           #        lb_x_std = np.sqrt(M2var @ (u_vec**2)/4) # std. dev in estimating x
   445                                                   # Fitting Error compuation (For each target)
   446     17114    3242234.0    189.4      3.9          N_mat2 = Me2 @ Z.T + 2*x_hat *L @ (Z.T) - ( L*L ) @ Z.T # eta
   447     17114     639760.0     37.4      0.8          U_mat = N_mat2 @ Wi # Optimal dual var.
   448     17114    7822420.0    457.1      9.5          g_nu2 = np.sqrt(np.sum(N_mat2 * U_mat) - np.sum((U_mat@Z)**2)/4)
   449     17114    4573268.0    267.2      5.5          cls.gc = ((cfg.rd_wt[0]*(V_mat@Z/2)**2/M1var + cfg.rd_wt[1]*((U_mat@Z/2)**2)/M2var))
   450                                                   
   451     17114     909733.0     53.2      1.1          xsa = x_hat - L
   452     17114    8012014.0    468.2      9.7          y_est = np.sqrt(abs(np.mean(Me2 - xsa **2))) # TODO: handle negative value properly
   453     17114    6196097.0    362.0      7.5          vy_est = np.mean(Me - v_hat*xsa) / y_est # Estimated using other estimates
   454                                                   
   455     17114    1087398.0     63.5      1.3          Stn = np.array([x_hat, y_est, v_hat, vy_est])
   456     17114    3756275.0    219.5      4.5          Pn = np.diag([g_nu, g_nu2])
   457     17114     798360.0     46.6      1.0          new_state = State(Stn, Pn)
   458     17114     239532.0     14.0      0.3          return new_state

